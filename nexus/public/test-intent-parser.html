<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Intent Parser Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
    }
    .test-case {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
    }
    .test-case h3 {
      margin-top: 0;
      color: #555;
    }
    .input {
      font-family: monospace;
      padding: 8px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      display: block;
      margin: 10px 0;
    }
    .result {
      margin-top: 10px;
      padding: 10px;
      background: #fff;
      border-left: 4px solid #4CAF50;
    }
    .result.loading {
      border-left-color: #2196F3;
    }
    .result.error {
      border-left-color: #f44336;
    }
    pre {
      margin: 5px 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #45a049;
    }
    .summary {
      margin: 20px 0;
      padding: 15px;
      background: #e3f2fd;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Intent Parser Test Suite</h1>
    <div class="summary">
      <strong>Test Summary:</strong>
      <div id="summary">Not yet run</div>
    </div>
    <button onclick="runAllTests()">Run All Tests</button>
    <div id="tests"></div>
  </div>

  <script type="module">
    // Import the intent parser (will need actual path when built)
    // For now, we'll use a simulated test with the actual patterns

    const testCases = [
      {
        name: 'Email sending with recipient and message',
        input: 'Send email to john@test.com saying hello',
        expected: {
          category: 'communication',
          action: 'send_email',
          entities: {
            person: 'john@test.com',
            message: 'hello',
          },
        },
      },
      {
        name: 'Slack posting with channel and message',
        input: "Post 'Hello team' to #general on Slack",
        expected: {
          category: 'communication',
          action: 'slack_post',
          entities: {
            message: 'Hello team',
            channel: 'general',
          },
        },
      },
      {
        name: 'Get emails with quantity',
        input: 'Get my last 5 emails',
        expected: {
          category: 'communication',
          action: 'get_emails',
          entities: {
            quantity: '5',
          },
        },
      },
      {
        name: 'Create calendar event with time',
        input: 'Create a Google Calendar event for tomorrow 3pm',
        expected: {
          category: 'scheduling',
          action: 'create',
          entities: {
            time: 'tomorrow 3pm',
          },
        },
      },
    ]

    // Store results globally for Playwright to access
    window.testResults = {
      passed: 0,
      failed: 0,
      total: testCases.length,
      tests: []
    }

    // Simulate intent parsing (in reality this would import the actual parser)
    async function parseIntent(input) {
      // Pattern matching simulation
      const normalized = input.toLowerCase()

      // Email pattern
      if (/send\s+(?:an?\s+)?email\s+to\s+([^\s]+@[^\s]+)\s+saying\s+(.+)/i.test(input)) {
        const match = input.match(/send\s+(?:an?\s+)?email\s+to\s+([^\s]+@[^\s]+)\s+saying\s+(.+)/i)
        return {
          category: 'communication',
          action: 'send_email',
          entities: [
            { type: 'person', value: match[1] },
            { type: 'message', value: match[2] },
          ],
          confidence: 0.9,
        }
      }

      // Slack pattern
      if (/post\s+['"](.+)['"]\s+to\s+[#]?(\w+)\s+on\s+slack/i.test(input)) {
        const match = input.match(/post\s+['"](.+)['"]\s+to\s+[#]?(\w+)\s+on\s+slack/i)
        return {
          category: 'communication',
          action: 'slack_post',
          entities: [
            { type: 'message', value: match[1] },
            { type: 'channel', value: match[2] },
          ],
          confidence: 0.9,
        }
      }

      // Get emails pattern
      if (/get\s+(?:my\s+)?last\s+(\d+)\s+emails?/i.test(input)) {
        const match = input.match(/get\s+(?:my\s+)?last\s+(\d+)\s+emails?/i)
        return {
          category: 'communication',
          action: 'get_emails',
          entities: [
            { type: 'quantity', value: match[1] },
          ],
          confidence: 0.9,
        }
      }

      // Calendar event pattern
      if (/create\s+(?:a\s+)?(?:google\s+)?calendar\s+event\s+for\s+(.+)/i.test(input)) {
        const match = input.match(/create\s+(?:a\s+)?(?:google\s+)?calendar\s+event\s+for\s+(.+)/i)
        return {
          category: 'scheduling',
          action: 'create',
          entities: [
            { type: 'time', value: match[1] },
          ],
          confidence: 0.9,
        }
      }

      return {
        category: 'custom',
        action: 'execute',
        entities: [],
        confidence: 0.3,
      }
    }

    async function runTest(testCase, index) {
      const testDiv = document.getElementById(`test-${index}`)
      const resultDiv = testDiv.querySelector('.result')

      resultDiv.className = 'result loading'
      resultDiv.innerHTML = '<strong>Testing...</strong>'

      try {
        const result = await parseIntent(testCase.input)

        // Verify results
        const checks = []
        let passed = true

        // Check category
        if (result.category === testCase.expected.category) {
          checks.push(`✓ Category: ${result.category}`)
        } else {
          checks.push(`✗ Category: expected ${testCase.expected.category}, got ${result.category}`)
          passed = false
        }

        // Check action
        if (result.action === testCase.expected.action || result.action.includes(testCase.expected.action)) {
          checks.push(`✓ Action: ${result.action}`)
        } else {
          checks.push(`✗ Action: expected ${testCase.expected.action}, got ${result.action}`)
          passed = false
        }

        // Check entities
        if (testCase.expected.entities) {
          for (const [entityType, expectedValue] of Object.entries(testCase.expected.entities)) {
            const entity = result.entities.find(e =>
              e.type === entityType ||
              e.value.toLowerCase().includes(expectedValue.toLowerCase())
            )
            if (entity) {
              checks.push(`✓ Entity ${entityType}: ${entity.value}`)
            } else {
              checks.push(`✗ Entity ${entityType}: expected "${expectedValue}", not found`)
              passed = false
            }
          }
        }

        resultDiv.className = passed ? 'result' : 'result error'
        resultDiv.innerHTML = `
          <strong>${passed ? '✅ PASSED' : '❌ FAILED'}</strong>
          <pre>${checks.join('\n')}</pre>
          <details>
            <summary>Full Result</summary>
            <pre>${JSON.stringify(result, null, 2)}</pre>
          </details>
        `

        // Update test results
        if (passed) {
          window.testResults.passed++
        } else {
          window.testResults.failed++
        }

        window.testResults.tests.push({
          name: testCase.name,
          passed,
          result,
          checks,
        })

      } catch (error) {
        resultDiv.className = 'result error'
        resultDiv.innerHTML = `<strong>❌ ERROR</strong><pre>${error.message}</pre>`
        window.testResults.failed++
        window.testResults.tests.push({
          name: testCase.name,
          passed: false,
          error: error.message,
        })
      }

      updateSummary()
    }

    function updateSummary() {
      const summary = document.getElementById('summary')
      const { passed, failed, total } = window.testResults
      summary.innerHTML = `
        <strong>${passed}/${total} tests passed</strong>
        ${failed > 0 ? `<span style="color: #f44336;">(${failed} failed)</span>` : '<span style="color: #4CAF50;">(All tests passed!)</span>'}
      `
    }

    window.runAllTests = async function() {
      // Reset results
      window.testResults = {
        passed: 0,
        failed: 0,
        total: testCases.length,
        tests: []
      }

      // Run tests sequentially
      for (let i = 0; i < testCases.length; i++) {
        await runTest(testCases[i], i)
        await new Promise(resolve => setTimeout(resolve, 100)) // Small delay between tests
      }
    }

    // Initialize test cases display
    const testsDiv = document.getElementById('tests')
    testCases.forEach((testCase, index) => {
      const testDiv = document.createElement('div')
      testDiv.className = 'test-case'
      testDiv.id = `test-${index}`
      testDiv.innerHTML = `
        <h3>${testCase.name}</h3>
        <div class="input">${testCase.input}</div>
        <div class="result">Not yet run</div>
      `
      testsDiv.appendChild(testDiv)
    })
  </script>
</body>
</html>
